from typing import Optional
import os
import pefile


class ProxyPESourceGenerator:
    def __init__(self, pe_file_path: str, pe_file_path_in_source_file: Optional[str] = None):
        if pe_file_path_in_source_file:
            self.__file_path = pe_file_path_in_source_file
        else:
            self.__file_path = pe_file_path
        pe = pefile.PE(pe_file_path)
        if pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE['IMAGE_FILE_MACHINE_AMD64']:
            self.__is_amd64 = True
        elif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE['IMAGE_FILE_MACHINE_I386']:
            self.__is_amd64 = False
        else:
            raise ValueError('Unsupported architecture')
        if not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            raise ValueError('PE file does not have export directory')
        if not hasattr(pe.DIRECTORY_ENTRY_EXPORT, 'symbols'):
            raise ValueError('PE file does not have any export symbols')
        self.__export_symbols = [(symbol.name.decode(), symbol.ordinal) for symbol in pe.DIRECTORY_ENTRY_EXPORT.symbols]
        self.__templates_path = os.path.join(os.path.split(os.path.realpath(__file__))[0], 'templates')

    def __copy_template_file(self, file_name: str, target_path: str, encoding: str):
        with open(os.path.join(self.__templates_path, file_name), 'r', encoding='utf-8') as template_file:
            with open(os.path.join(target_path, file_name), 'w', encoding=encoding) as target_file:
                target_file.write(template_file.read())

    def generate_source(self, source_path: str = '.', encoding: str = 'utf-8') -> str:
        if not os.path.exists(source_path):
            os.makedirs(source_path)

        # Copy ProxyLibrary.c, ProxyLibrary.h, and ProxyLibraryGlobals.h
        self.__copy_template_file('ProxyLibrary.c', source_path, encoding)
        self.__copy_template_file('ProxyLibrary.h', source_path, encoding)
        self.__copy_template_file('ProxyLibraryGlobals.h', source_path, encoding)

        # Generate ProxyLibraryExports.def
        with open(os.path.join(source_path, 'ProxyLibraryExports.def'), 'w', newline='', encoding=encoding) as def_file:
            def_file.write('; Generated by ProxyPESourceGenerator\r\n\r\n')
            def_file.write(f'LIBRARY "{os.path.splitext(os.path.basename(self.__file_path))[0]}"\r\n')
            def_file.write('EXPORTS\r\n')
            for symbol in self.__export_symbols:
                def_file.write(f'{symbol[0]} @{symbol[1]}\r\n')

        # Generate ProxyLibraryGlobals.c
        with open(os.path.join(source_path, 'ProxyLibraryGlobals.c'), 'w', newline='', encoding=encoding) as c_file:
            symbol_count = len(self.__export_symbols)
            c_file.write('// Generated by ProxyPESourceGenerator\r\n\r\n')
            c_file.write('#include "ProxyLibraryGlobals.h"\r\n\r\n')
            c_file.write(f'LPCSTR libraryFilePath = "{self.__file_path.replace('\\', '\\\\')}";\r\n')
            c_file.write(f'SIZE_T symbolCount = {symbol_count};\r\n')
            c_file.write(f'FARPROC symbolAddressArray[{symbol_count}];\r\n')
            c_file.write(f'LPCSTR symbolNameArray[{symbol_count}] = {{\r\n')
            for symbol in self.__export_symbols:
                c_file.write(f'    "{symbol[0]}",\r\n')
            c_file.write('};\r\n')

        # Generate ProxyLibraryExports.asm
        with open(os.path.join(source_path, 'ProxyLibraryExports.asm'), 'w', newline='', encoding=encoding) as asm_file:
            asm_file.write('; Generated by ProxyPESourceGenerator\r\n\r\n')
            if not self.__is_amd64:
                asm_file.write('.model flat, stdcall\r\n\r\n')
            asm_file.write('.data\r\n')
            asm_file.write(f'extern symbolAddressArray:{"qword" if self.__is_amd64 else "dword"}\r\n\r\n')
            asm_file.write('.code\r\n')
            for i, symbol in enumerate(self.__export_symbols):
                asm_file.write(f'{symbol[0]} proc\r\n')
                asm_file.write(f'    jmp symbolAddressArray+{i * (8 if self.__is_amd64 else 4)}\r\n')
                asm_file.write(f'{symbol[0]} endp\r\n')
            asm_file.write('end\r\n')
